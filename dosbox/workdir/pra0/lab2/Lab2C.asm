;**************************************************************************
; MBS 2021. LABORATORY ASSIGNMENT 2
; Author: PABLO IZAGUIRRE GARCIA
; Group: 2291
; Task: 2
;**************************************************************************

; DATA SEGMENT DEFINITION
DATA SEGMENT
    ; VECTOR DEFINITION
    vector1         db 1,2,2,4
    vector2         db 4,2,5,1
    vector3         db 3,2,4,1
    vectorAux       DB ?,?,?,?
    errorNumDif     DB "Outside the set: [1,4]", 13, 10, '$'
    errorDuplicated DB "Duplicated", 13, 10, '$'
    correctOutput   DB "Correct", 13, 10, '$'
    numString       DB 7 dup(" ")           ; AN INTEGER CAN HAVE AT MOST 5 DIGITS
    pNumString      DD numString
    txtSpace    	DB 	" ", "$"
DATA ENDS

;**************************************************************************
; STACK SEGMENT DEFINITION
STACKSEG SEGMENT STACK "STACK"
    DB 40H DUP (0) ; initialization example, 64 bytes initialize to 0
STACKSEG ENDS

;**************************************************************************
; EXTRA SEGMENT DEFINITION
EXTRA SEGMENT
    RESULT DW 0,0 ; initialization example. 2 WORDS (4 BYTES)
EXTRA ENDS
;************************************************************************** 


; CODE SEGMENT DEFINITION
CODE SEGMENT
ASSUME CS: CODE, DS: DATA, ES: EXTRA, SS: STACKSEG
; BEGINNING OF MAIN PROCEDURE
BEGIN PROC
    ; INITIALIZE THE SEGMENT REGISTER WITH ITS VALUE
    MOV AX, DATA
    MOV DS, AX
    MOV AX, STACKSEG
    MOV SS, AX
    MOV AX, EXTRA
    MOV ES, AX
    MOV SP, 64 ; LOAD A STACK POINTER WITH THE HIGHEST VALUE
    ; END OF INITIALIZATIONS
    ; BEGINNING OF THE PROGRAM
    
    ; BP REPRESENTS WHICH VECTOR THE PROGRAM IS ANALYZING
    MOV BP, 0
IR:
    CALL PRINTVECTOR
    CALL VECTORINRANGE
    ; IF SI IS 4 IT MEANS THAT THE ELEMENTS OF THE VECTOR ARE IN THE CORRECT RANGE
    CMP SI, 4
    ; IF IT THE VECTOR IS INCORRECT WE DONT HAVE TO CHECK IF THERE ARE DUPLICATES
    JNE NEXTVECTOR
    CALL VECTORDUPLICATES

NEXTVECTOR:
    ; WE LOOK AT THE NEXT VECTOR (BP IS INCREASED BY 4 BECAUSE THATS THE SIZE OF EACH VECTOR)
    ADD BP, 4
    ; IF THERE ARE STILL MORE VECTORS TO CHECK, THE PROGRAM JUMPS TO IR
    CMP BP, 12
    JNE IR    


    ; END OF THE PROGRAM
    MOV AX, 4C00H
    INT 21H
BEGIN ENDP


; SPACE FOR SUBROUTINES

; THIS SUBROUTINE TRANSFORMS AN INTEGER INTO AN ASCII STRING. THE INTEGER HAS TO BE STORED IN AX AND THE ROUTINE WILL
; RETURN THE MEMORY ADDRESS WHERE THE STRING IS STORED IN DX:BX
TOSTRING PROC NEAR
    MOV BX, 10
    ; SI CONTAINS THE INDEX IN THE STRING WHERE THE NEXT NUMBER HAS TO BE WRITTEN
    MOV SI, 5
IRTOSTRING:
    ; WE MAKE SURE DX IS SET TO 0
    MOV DX, 0
    ; AX IS DIVIDED BY 10
    IDIV BX
    ; THE REMAINDER OF THE DIVISION IS STORED IN DX, SO WE INCREMENT THIS NUMBER BY THE POSITION OF 0 IN THE ASCII TABLE (30H)
    ADD DX, 30H
    ; THIS NUMBER (BETWEEN 30H AND 39H) IS STORED IN THE NEXT AVAILABLE POSITION IN THE ARRAY
    MOV numString[SI], DL
    DEC SI
    ; IF THE QUOTIENT IS 0 IT MEANS THAT WE HAVE ALREADY FOUND THE LAST DIGIT
    CMP AX, 0
    JNE IRTOSTRING

    MOV numString[SI], " "
    MOV numString[6], "$"
    MOV BX, WORD PTR pNumString
    ; BX HAS THE PREVIOUS POSITION TO THE ONE WHERE THE MOST SIGNIFICANT DIGIT WAS STORED
    ADD BX, SI
    ; DX HAS THE SEGMENT WHERE THE STRING IS LOCATED
    MOV DX, WORD PTR pNumString[2]
    RET
TOSTRING ENDP

; THIS SUBROUTINE PRINTS THE ELEMENTS OF THE VECTOR BP
PRINTVECTOR PROC NEAR
    MOV DI, 0
IR4:
    MOV AH, 0
    MOV AL, vector1[BP][DI]
    ; A STRING WITH THE NUMBER IS CREATED
    CALL TOSTRING
    ; THE STRING IS PRINTED
    MOV AH, 9
    MOV DS, DX
    MOV DX, BX
    INT 21H
    ; WE REPEAT THIS FOR ALL THE ELEMENTS IN THE VECTOR
    INC DI
    CMP DI, 4
    JNE IR4
    ; WE PRINT AN EXTRA SPACE
    MOV DX, OFFSET txtSpace
	INT 21H
    RET
PRINTVECTOR ENDP

; THIS SUBROUTINE CHECKS IF THE VECTOR BP IS BETWEEN 1 AND 4
VECTORINRANGE PROC NEAR
    ; SI INDICATES THE INDEX INSIDE THE VECTOR
    MOV SI, 0
IR2:
    ; FIRST I CHECK IF THIS ELEMENT OF THE VECTOR IS GREATER OR EQUAL THAN ONE
    CMP vector1[BP][SI], 1
    JGE GREATERTHANONE
    ; IF THE NUMBER IS SMALLER THAN ONE THEN WE PRINT THE ERROR MESSAGE AND PROCEED TO ANALYZE THE NEXT VECTOR
    CALL PRINTERROR
    RET

    ; IF THE NUMBER WAS GREATER THAN ONE, NOW WE HAVE TO CHECK IF IT IS SMALLER OR EQUAL TO 4
GREATERTHANONE:
    CMP vector1[BP][SI], 4
    JLE LESSTHANFOUR
    ; IF THE NUMBER WAS GREATER THAN FOUR THEN WE PRINT THE ERROR MESSAGE AND PROCEED TO ANALYZE THE NEXT VECTOR
    CALL PRINTERROR
    RET

LESSTHANFOUR:
    ; IF NO ERROR HAS BEEN FOUND, WE LOOK AT THE NEXT VALUE OF THE VECTOR
    INC SI
    ; IF THERE ARE STILL SOME NUMBERS TO CHECK FROM THIS VECTOR WE ANALYZE THE NEXT ELEMENT
    CMP SI, 4
    JNE IR2
    ; IF THE PROGRAM REACHES THIS POINT, IT MEANS THAT VECTOR[BP] IS CORRECT
    RET
VECTORINRANGE ENDP

; THIS SUBROUTINE CHECKS IF THE VECTOR BP HAS NO DUPLICATE NUMBERS
VECTORDUPLICATES PROC NEAR
    ; SI INDICATES THE INDEX INSIDE THE VECTOR
    MOV SI, 0
IR3:
    ; DI INDICATES THE INDEX OF THE ELEMENTS INSIDE OF THE VECTOR WHERE WE STORE THE NUMBERS ALREADY USED
    MOV DI, SI
    ; WE STORE THE CURRENT NUMBER IN AH
    MOV AH, vector1[BP][SI]
CHECK_DUPES:
    DEC DI
    ; IF DI IS EQUAL TO -1, THEN THE AUXILIARY VECTOR HAS BEEN CHECKED COMPLETELY AND NO DUPLICATE HAS BEEN FOUND
    CMP DI, -1
    JE CORRECT
    ; COMPARATION OF THE VALUE WITH EACH OF THE PREVIOUS ONES
    CMP vectorAux[DI], AH
    JNE CHECK_DUPES
    ; IF THERE WAS A DUPLICATE WE PRINT THE DUPLICATE MESSAGE AND PROCEED TO ANALYZE THE NEXT VECTOR
    CALL PRINTDUP
    RET

CORRECT:
    ; THE ANALYZED NUMBER IS STORED IN THE AUXILIARY VECTOR
    MOV vectorAux[SI], AH
    ; WE CHECK IF THE WHOLE VECTOR HAS BEEN ANALYZED 
    INC SI
    CMP SI, 4
    JNE IR3
    ; IF THE PROGRAM REACHES THIS POINT, IT MEANS THAT VECTOR[BP] IS CORRECT
    ; WE PRINT CORRECT
    CALL PRINTCORRECT
    RET
VECTORDUPLICATES ENDP

; THIS SUBROUTINE PRINTS THE DUPLICATED MESSAGE
PRINTDUP PROC NEAR
    MOV AH, 9
    MOV DX, OFFSET errorDuplicated
    INT 21H
    RET
PRINTDUP ENDP

; THIS SUBROUTINE PRINTS THE ERROR MESSAGE
PRINTERROR PROC NEAR
    MOV AH, 9
    MOV DX, OFFSET errorNumDif
    INT 21H
    RET
PRINTERROR ENDP

; THIS SUBROUTINE PRINTS THE DUPLICATED MESSAGE
PRINTCORRECT PROC NEAR
    MOV AH, 9
    MOV DX, OFFSET correctOutput
    INT 21H
    RET
PRINTCORRECT ENDP

; END OF THE CODE SEGMENT
CODE ENDS
; END OF THE PROGRAM POINTING OUT WHERE THE EXECUTION BEGINS
END BEGIN