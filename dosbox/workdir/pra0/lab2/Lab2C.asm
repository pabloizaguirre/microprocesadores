;**************************************************************************
; MBS 2021. LABORATORY ASSIGNMENT 2
; Author: PABLO IZAGUIRRE GARCIA
; Group: 2291
; Task: 1
;**************************************************************************

; DATA SEGMENT DEFINITION
DATA SEGMENT
    ; VECTOR DEFINITION
    vector1         DB 1,2,0,4
    vector2         DB 4,-2,2,1
    vector3         DB 0,2,0,-1
    vectorAux       DB ?,?,?,?
    errorNumDif     DB "Outside the set: [1,4]", 13, 10, '$'
    errorDuplicated DB "Duplicated", 13, 10, '$'
    correctOutput   DB "Correct", 13, 10, '$'
    numString       DB 7 dup(" ")
    pNumString      DD numString
DATA ENDS

;**************************************************************************
; STACK SEGMENT DEFINITION
STACKSEG SEGMENT STACK "STACK"
    DB 40H DUP (0) ; initialization example, 64 bytes initialize to 0
STACKSEG ENDS

;**************************************************************************
; EXTRA SEGMENT DEFINITION
EXTRA SEGMENT
    RESULT DW 0,0 ; initialization example. 2 WORDS (4 BYTES)
EXTRA ENDS
;************************************************************************** 


; CODE SEGMENT DEFINITION
CODE SEGMENT
ASSUME CS: CODE, DS: DATA, ES: EXTRA, SS: STACKSEG
; BEGINNING OF MAIN PROCEDURE
BEGIN PROC
    ; INITIALIZE THE SEGMENT REGISTER WITH ITS VALUE
    MOV AX, DATA
    MOV DS, AX
    MOV AX, STACKSEG
    MOV SS, AX
    MOV AX, EXTRA
    MOV ES, AX
    MOV SP, 64 ; LOAD A STACK POINTER WITH THE HIGHEST VALUE
    ; END OF INITIALIZATIONS
    ; BEGINNING OF THE PROGRAMME
    
    MOV AX, 3127
    CALL TOSTRING

    ; THE STRING IS PRINTED
    MOV AH, 9
    MOV DS, DX
    MOV DX, BX
    INT 21H

    ; END OF THE PROGRAMME
    MOV AX, 4C00H
    INT 21H
BEGIN ENDP


; SPACE FOR SUBROUTINES

; THIS SUBROUTINE TRANSFORMS AN INTEGER INTO AN ASCII STRING
TOSTRING PROC NEAR
    MOV BX, 10
    ; SI CONTAINS THE INDEX IN THE STRING WHERE THE NEXT NUMBER HAS TO BE WRITTEN
    MOV SI, 5
IRTOSTRING:
    ; WE MAKE SURE DX IS SET TO 0
    MOV DX, 0
    ; AX IS DIVIDED BY 10
    IDIV BX
    ; THE REMAINDER OF THE DIVISION IS STORED IN DX, SO WE INCREMENT THIS NUMBER BY THE POSITION OF 0 IN THE ASCII TABLE (30H)
    ADD DX, 30H
    ; THIS NUMBER (BETWEEN 30H AND 39H) IS STORED IN THE NEXT AVAILABLE POSITION IN THE ARRAY
    MOV numString[SI], DL
    DEC SI
    ; IF THE QUOTIENT IS 0 IT MEANS THAT WE HAVE ALREADY FOUND THE LAST DIGIT
    CMP AX, 0
    JNE IRTOSTRING

    MOV numString[6], "$"
    MOV BX, WORD PTR pNumString
    ; BX HAS THE PREVIOUS POSITION TO THE ONE WHERE THE MOST SIGNIFICANT DIGIT WAS STORED
    ADD BX, SI
    ; DX HAS THE SEGMENT WHERE THE STRING IS LOCATED
    MOV DX, WORD PTR pNumString[2]
    RET

TOSTRING ENDP

; THIS SUBROUTINE PRINTS THE DUPLICATED MESSAGE
PRINTDUP PROC NEAR
    MOV AH, 9
    MOV DX, OFFSET errorDuplicated
    INT 21H
    RET
PRINTDUP ENDP

; THIS SUBROUTINE PRINTS THE ERROR MESSAGE
PRINTERROR PROC NEAR
    MOV AH, 9
    MOV DX, OFFSET errorNumDif
    INT 21H
    RET
PRINTERROR ENDP

; THIS SUBROUTINE PRINTS THE DUPLICATED MESSAGE
PRINTCORRECT PROC NEAR
    MOV AH, 9
    MOV DX, OFFSET correctOutput
    INT 21H
    RET
PRINTCORRECT ENDP

; END OF THE CODE SEGMENT
CODE ENDS
; END OF THE PROGRAMME POINTING OUT WHERE THE EXECUTION BEGINS
END BEGIN