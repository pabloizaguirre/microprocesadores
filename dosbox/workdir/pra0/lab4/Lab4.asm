; DATA SEGMENT DEFINITION
DATA SEGMENT
    ; VECTOR DEFINITION
    vector1         DB 1,2,2,1
    vector2         DB 6,3,1,1
    vector3         DB 1,2,0,1
    errorNumDif     DB "Outside the set: [1,4]", 13, 10, '$'
    correctOutput   DB "Correct", 13, 10, '$'
DATA ENDS

;**************************************************************************
; STACK SEGMENT DEFINITION
STACKSEG SEGMENT STACK "STACK"
    DB 40H DUP (0) ; initialization example, 64 bytes initialize to 0
STACKSEG ENDS

;**************************************************************************
; EXTRA SEGMENT DEFINITION
EXTRA SEGMENT
    RESULT DW 0,0 ; initialization example. 2 WORDS (4 BYTES)
EXTRA ENDS
;************************************************************************** 


; CODE SEGMENT DEFINITION
CODE SEGMENT
ASSUME CS: CODE, DS: DATA, ES: EXTRA, SS: STACKSEG
MODO_VIDEO DB 0
; BEGINNING OF MAIN PROCEDURE
BEGIN PROC
    ; INITIALIZE THE SEGMENT REGISTER WITH ITS VALUE
    MOV AX, DATA
    MOV DS, AX
    MOV AX, STACKSEG
    MOV SS, AX
    MOV AX, EXTRA
    MOV ES, AX
    MOV SP, 64 ; LOAD A STACK POINTER WITH THE HIGHEST VALUE
    ; END OF INITIALIZATIONS
    ; BEGINNING OF THE PROGRAM

    ; We use 10h interrupciÃ³n to enter in video mode
    MOV AH,0Fh ; Asking for video mode
    INT 10h ; Call to BIOS
    MOV MODO_VIDEO,AL ; We save the video mode and store it into AL
    mov ah, 00h ; We set the video mode
    mov al, 12h ; 640x480 16 color graphics (VGA)
    int 10h

    mov ah, 100
    mov al, 50
    int 57h
    int 55h
    
    ;Int15H active waiting in milliseconds: 1 millon us = 1 segundo
    MOV     CX, 2Dh ; CX:DX are the waiting time: 1 second = F:4240H --> 3 seconds 2D:C6C0h
    MOV     DX, 0C6C0h
    MOV     AH, 86H ;int15h with AH=86h to microseconds waiting in CX:DX
    INT     15H

    mov ah, 00h ; Restore the input configuration to video mode
    mov al, MODO_VIDEO ; 
    int 10h

    ; BX REPRESENTS WHICH VECTOR WE ARE ANALYZING
    MOV BX, 0  
IR:
    CALL VECTORINRANGE
    ; WE LOOK AT THE NEXT VECTOR (BX IS INCREASED BY 4 BECAUSE THATS THE SIZE OF EACH VECTOR)
    ADD BX, 4
    ; IF THERE ARE STILL MORE VECTORS TO CHECK, THE PROGRAM JUMPS TO IR
    CMP BX, 12
    JNE IR

    ; END OF THE PROGRAM
    MOV AX, 4C00H
    INT 21H
BEGIN ENDP


; SPACE FOR SUBROUTINES

; THIS SUBROUTINE CHECKS IF THE VECTOR BX IS BETWEEN 1 AND 4
VECTORINRANGE PROC NEAR
    ; SI INDICATES THE INDEX INSIDE THE VECTOR
    MOV SI, 0
IR2:
    ; FIRST I CHECK IF THIS ELEMENT OF THE VECTOR IS GREATER OR EQUAL THAN ONE
    CMP vector1[BX][SI], 1
    JGE GREATERTHANONE
    ; IF THE NUMBER IS SMALLER THAN ONE THEN WE PRINT THE ERROR MESSAGE AND PROCEED TO ANALYZE THE NEXT VECTOR
    CALL PRINTERROR
    RET

    ; IF THE NUMBER WAS GREATER THAN ONE, NOW WE HAVE TO CHECK IF IT IS SMALLER OR EQUAL TO 4
GREATERTHANONE:
    CMP vector1[BX][SI], 4
    JLE LESSTHANFOUR
    ; IF THE NUMBER WAS GREATER THAN FOUR THEN WE PRINT THE ERROR MESSAGE AND PROCEED TO ANALYZE THE NEXT VECTOR
    CALL PRINTERROR
    RET

LESSTHANFOUR:
    ; IF NO ERROR HAS BEEN FOUND, WE LOOK AT THE NEXT VALUE OF THE VECTOR
    INC SI
    ; IF THERE ARE STILL SOME NUMBERS TO CHECK FROM THIS VECTOR WE ANALYZE THE NEXT ELEMENT
    CMP SI, 4
    JNE IR2
    ; IF THE PROGRAM REACHES THIS POINT, IT MEANS THAT VECTOR[BX] IS CORRECT
    ; WE PRINT CORRECT
    MOV AH, 9
    MOV DX, OFFSET correctOutput
    INT 21H
    RET
VECTORINRANGE ENDP

; THIS SUBROUTINE PRINTS THE ERROR MESSAGE
PRINTERROR PROC NEAR
    MOV AH, 9
    MOV DX, OFFSET errorNumDif
    INT 21H
    RET
PRINTERROR ENDP

; END OF THE CODE SEGMENT
CODE ENDS
; END OF THE PROGRAM POINTING OUT WHERE THE EXECUTION BEGINS
END BEGIN